GROUP BY
Summarizing or aggregating data by groups. Split-Apply-Combine
To get in-depth information by group; almost exclusively used with AGGREGATE functions
-- Example: How many employees work in each department
    SELECT dept_no, COUNT(emp_no),
    FROM dept_no
    GROUP BY dept_no;
*Functions must apply to all columns that are not within GROUP BY*

HAVING
Filters on GROUP

________________________________________________________________________________________________________________________________________________________________________________

WINDOW 
Apply functions to a subset or window of data
    window_function(arg1, arg2,...) OVER (
        [PARTITION BY partition_expression]
        [ORDER BY sort_expression [ASC|DESC] [NULLS {FIRST|LAST}]
*Needs 'OVER' keyword to apply function over window of data requested*
-- Example: Display the max salary next to each row
    SELECT
        *,
        MAX(salary) OVER()
    FROM salaries;
    
PARTITION BY
Divide rows into groups to apply the function against
-- Example: Display average salary by department name next to individual salaries
    SELECT
        *,
        AVG(salary) OVER(
            PARTITION BY d.dept_name
        )
    FROM salaries
    JOIN dept_emp as de USING (emp_no)
    JOIN departments AS d USING (dept_no)
    
FIRST_VALUE
Return a value evaluated aginst the first row within its partition 
-- Example: Price of item compared to the lowest price of item in its category
SELECT
    prod_id,
    price,
    category,
    first_value(price) OVER(
        PARTITION by category ORDER BY price RANGE between UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    )
FROM products 
* May be better to use min(price) in this situation

ROW_NUMBER
Number the current row within the partition starting from 1 regardless of framing
-- Example: Where product is positioned in the category by price
SELECT
    prod_id,
    price,
    category,
    row_number() OVER(
        PARITION by category ORDER BY price) as "Position in Category by Price"
FROM products

________________________________________________________________________________________________________________________________________________________________________________

CASE
Conditionals
-- Example:
    SELECT a,
        CASE WHEN a = 1 THEN 'one'
             WHEN a = 2 THEN 'two'
             ELSE 'other
        END
    FROM test;
* Each return must be a single output 
-- Example: In an aggregate function
    SELECT
        SUM(
            CASE
                WHEN o.netamount < 100
                then -100
                else o.netamount 
            END
        ) AS "returns",
        SUM(o.netamount) AS "normal total"
    FROM orders as o

NULLIF
Return null if a condition is met
-- Example: If value 1 equals value 2, return null
    NULLIF(val_1, val_2)

________________________________________________________________________________________________________________________________________________________________________________

VIEWS
Store and query previously run queries 
2 Types of Views: Materialized & Non-Materialized
Non-Materialized - Query gets re-run each time view is called on (storing reference)
Materialized - Stores data physically and periodically updates when tables change 
-- Syntax: Create view
    CREATE VIEW view_name AS query;
-- Syntax: Update view
    CREATE OR REPLACE <view name> AS query
-- Syntax: Rename view
    ALTER VIEW <view name> RENAME TO <view name>;
-- Syntax: Delete view
    DROP VIEW [IF EXISTS] <view name>
* Views are the output of the query ran
--Example: Current salary
    CREATE VIEW last_salary_change AS
    SELECT e.emp_no,
           MAX(s.from_date)
    FROM salaries as s
    
    JOIN employees as e USING(emp_no)
    JOIN dept_emp as de USING(emp_no)
    JOIN departments as d USING(dept_no)
    
    GROUP BY e.emp_no
    ORDER BY e.emp_no;
    
    SELECT * FROM salaries
    JOIN last_salary_change AS l USING (emp_no)
    WHERE from_date = l.max
    ORDER BY emp_no;

________________________________________________________________________________________________________________________________________________________________________________

INDEX
An index is a construct to improve querying performance
Single-Column, Multi-Column, Unique, Partial, Implicit 
-- Syntax: Create index
    CREATE UNIQUE INDEX <name>
    ON <table> (column1, column2, ...);
-- Syntax: Delete index
    DROP INDEX <name>;
* Index foreign keys, index primary & unique keys, index on columns that end up in the ORDER BY/WHERE clause often

SINGLE-COLUMN INDEX
Most frequently used column in a query 

MULTI-COLUMN INDEX
Most frequently used columns in query

UNIQUE INDEX
For speed and integrity

PARTIAL INDEX
Index over a subset of a table
-- Syntax:
    CREATE INDEX <name>
    ON <table> (<expression>);
    
IMPLICIT
Automatically created by the database: primary and unique keys
